--- 
title: "Notes on a design of a simple spatial sampling method (S3M) for assessing coverage of health and nutrition programmes in Liberia"
author: "Valid International"
date: "`r Sys.Date()`"
knit: bookdown::render_book
site: bookdown::bookdown_site
documentclass: book
geometry: margin=2cm
classoption: a4paper
bibliography: ["book.bib"]
biblio-style: "apalike"
link-citations: TRUE
links-as-notes: FALSE
colorlinks: TRUE
fontsize: 12pt
url: http\://design.validmeasures.com/liberiaS3M
cover-image: figures/s3mlogo.png
description: "Notes on a design of a simple spatial sampling method (S3M) for assessing coverage of health and nutrition programmes in Liberia"
---

```{r, echo = FALSE, warning = FALSE, message = FALSE, cache = TRUE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  collapse = TRUE,
  comment = "#>",
  fig.path = "figures/"
)
options(stringsAsFactors = FALSE)

if(!require(devtools)) install.packages("devtools")
if(!require(rgdal)) install.packages("rgdal")
if(!require(rgeos)) install.packages("rgeos")
if(!require(raster)) install.packages("raster")
if(!require(liberia)) install_github("validmeasures/liberia")
if(!require(maps)) install.packages("maps")
if(!require(knitr)) install.packages("knitr")
if(!require(kableExtra)) install.packages("kableExtra")

wca <- rgdal::readOGR(dsn = "maps/wca_adm0",
                      layer = "wca_adm0",
                      verbose = FALSE)

roads <- rgdal::readOGR(dsn = "maps/lbr_rdsl_unmil",
                        layer = "lbr_rdsl_unmil",
                        verbose = FALSE)

tracks <- subset(roads, CATEGORY %in% c("Track", "Tracks"))
primary <- subset(roads, CATEGORY == "Primary Routes")
paved <- subset(roads, CATEGORY == "Paved") 

poi <- rgdal::readOGR(dsn = "maps/hotosm_liberia_points_of_interest_points_shp",
                      layer = "hotosm_liberia_points_of_interest_points",
                      verbose = FALSE)

montserrado1 <- counties[counties$admin1name == "Montserrado", ]
montserrado2 <- districts[districts$admin1Name == "Montserrado", ]

grandbassa1 <- counties[counties$admin1name == "Grand Bassa", ]
grandbassa2 <- districts[districts$admin1Name == "Grand Bassa", ]
```

# Simple Spatial Sampling Method (S3M) {-}

![](figures/s3mlogo.png)

<!--chapter:end:index.Rmd-->

# Introduction {#introduction}

The Simple Spatial Survey Method (S3M) was developed from the CSAS coverage survey method as a response to the widespread adoption of community management of acute malnutrition (CMAM) by ministries of health. Large-scale programs need a large-scale survey method and S3M was developed to meet that need.

S3M was designed to :

* Be simple enough for MoH, NGO, and UNO personnel without specialist statistical training to perform.

* Provide a general survey method. S3M can be used to survey and map :

* Need for and coverage of selective-entry programs such as CMAM and TSFP as well as universal programs such as EPI, GMP, GFD (general ration), and “blanket” SFP over wide areas.

* Levels of indicators such as those for IYCF, WASH, and period prevalence / cumulative prevalence of ARI, fever, and diarrhoea over wide areas.

This document concentrates on using S3M to assess the need for and coverage of a variety of selective-entry feeding programs. The indicators discussed in this manual are:

* Therapeutic feeding (OTP and TSFP) programs :

* Prevalence of SAM and coverage of treatment of SAM in children aged between 6 and 59
months.

* Prevalence of MAM and coverage of treatment of MAM in children aged between 6 and 59 months.

* Prevalence of MAM and treatment of MAM and in pregnant and lactating women (PLWs).

* Food-based prevention of malnutrition (FBPM) programs :

* Prevalence of need for and coverage of food-based prevention of malnutrition in younger children at risk of developing MAM and SAM.

* Prevalence of need for and coverage of food-based prevention of malnutrition in pregnant and lactating women (PLWs) at risk of developing MAM and SAM.

* Coverage of screening for all of the above programs.

* Coverage of Behaviour Change Communication (BCC) programs focussing on maternal and child health and nutrition to all principal carers of children (usually their mothers) and all PLWs.

<!--chapter:end:01-introduction.Rmd-->

# The survey sample {#sample}

The survey method described here uses a two-stage sample:

* **First-stage:** We take an even (or near-even) spatial sample of communities from all of the communities in the survey area.

* **Second-stage:** We take a sample of eligible individuals from each of the communities identified in the first stage of sampling.

Two-stage sampling is used in many survey methods. A typical example of a survey method that uses a two- stage sample is the SMART method that is commonly used for nutritional anthropometry surveys.

The main difference between the sample taken in S3M based surveys and in SMART type surveys is that S3M based samples used a spatial sample in the first stage whereas SMART type surveys use a proportional to population size (PPS) sample.

The advantages of using a spatial first stage sample is that such a sample allows us to identify where (and why) coverage is good, and where (and why) coverage is poor. This information is essential to improving program coverage and ensuring equitable access to services.

A spatial sample can be used to produce equivalent results to a traditional proportional to population size (PPS) sample as is used in (e.g.) SMART type surveys using a weighted analysis. This means that a spatial sample can be made to act as a PPS sample. A PPS type sample cannot, however, be made to act as a spatial sample.

<!--chapter:end:02-sample.Rmd-->

```{r, echo = FALSE, warning = FALSE, message = FALSE, cache = TRUE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  collapse = TRUE,
  comment = "#>",
  fig.path = "figures/"
)

options(stringsAsFactors = FALSE)

if(!require(devtools)) install.packages("devtools")
if(!require(rgdal)) install.packages("rgdal")
if(!require(rgeos)) install.packages("rgeos")
if(!require(raster)) install.packages("raster")
if(!require(spatialsampler)) install_github("validmeasures/spatialsampler")
if(!require(liberia)) install_github("validmeasures/liberia")
if(!require(maps)) install.packages("maps")
if(!require(knitr)) install.packages("knitr")
if(!require(kableExtra)) install.packages("kableExtra")
if(!require(magrittr)) install.packages("magrittr")
if(!require(FNN)) install.packages("FNN")

wca <- rgdal::readOGR(dsn = "maps/wca_adm0",
                      layer = "wca_adm0",
                      verbose = FALSE)

roads <- rgdal::readOGR(dsn = "maps/lbr_rdsl_unmil",
                        layer = "lbr_rdsl_unmil",
                        verbose = FALSE)

tracks <- subset(roads, CATEGORY %in% c("Track", "Tracks"))
primary <- subset(roads, CATEGORY == "Primary Routes")
paved <- subset(roads, CATEGORY == "Paved") 

poi <- rgdal::readOGR(dsn = "maps/hotosm_liberia_points_of_interest_points_shp",
                      layer = "hotosm_liberia_points_of_interest_points",
                      verbose = FALSE)

montserrado1 <- counties[counties$admin1name == "Montserrado", ]
montserrado2 <- districts[districts$admin1Name == "Montserrado", ]

grandbassa1 <- counties[counties$admin1name == "Grand Bassa", ]
grandbassa2 <- districts[districts$admin1Name == "Grand Bassa", ]

calculate_length <- function(d) {
  x <- (3 * d) / 2
  return(x)
}

calculate_height <- function(d) {
  y <- (sqrt(3) / 2) * d
  return(y)
}

montserradoUTM <- spTransform(montserrado1, CRSobj = CRS(as.character(map_projections$proj[map_projections$country == "Liberia"])))

montserradoBox <- montserradoUTM %>% 
  bbox() %>% 
  extent() %>% 
  as("SpatialPolygons")

proj4string(montserradoBox) <- proj4string(montserradoUTM)

montserradoBox <- create_buffer(x = montserradoBox, buffer = 6, country = "Liberia")

x <- seq(from = extent(montserradoBox)[1], to = extent(montserradoBox)[2], 
         by = calculate_length(d = 6000))

x1 <- seq(from = extent(montserradoBox)[1], to = extent(montserradoBox)[2], 
          by = calculate_length(d = 6000) * 2)

x2 <- seq(from = extent(montserradoBox)[1] + calculate_length(d = 6000), to = extent(montserradoBox)[2], 
          by = calculate_length(d = 6000) * 2)

y <- seq(from = extent(montserradoBox)[3], to = extent(montserradoBox)[4], 
         by = calculate_height(d = 6000))

y1 <- seq(from = extent(montserradoBox)[3], to = extent(montserradoBox)[4], 
          by = calculate_height(d = 6000) * 2)

y2 <- seq(from = extent(montserradoBox)[3] + calculate_height(d = 6000), to = extent(montserradoBox)[4], 
          by = calculate_height(d = 6000) * 2)

coords  <- NULL
coords1 <- NULL
coords2 <- NULL 

for(i in 1:length(x)) {
  for(j in 1:length(y)) {
    coords  <- rbind(coords, c(x[i], y[j]))
    coords1 <- rbind(coords1, c(x1[i], y1[j]))
    coords2 <- rbind(coords2, c(x2[i], y2[j]))
  }
}

coordsSP <- rbind(coords1, coords2)

coordsSP <- coordsSP[!is.na(coordsSP[ , 1]), ]
coordsSP <- coordsSP[!is.na(coordsSP[ , 2]), ]

a <- seq(from = 1, to = nrow(coords), by = length(y))
b <- seq(from = length(y), to = nrow(coords), by = length(y))

hline <- NULL

for(i in 1:length(x)) {
  temp <- Lines(Line(coords[a[i]:b[i], ]), ID = paste("hline", i, sep = ""))
  hline <- c(hline, temp)
}

coordsX <- coords[order(coords[ , 2]), ]

a <- seq(from = 1, to = nrow(coordsX), by = length(x))
b <- seq(from = length(x), to = nrow(coordsX), by = length(x))

vline <- NULL

for(i in 1:length(y)) {
  temp <- Lines(Line(coordsX[a[i]:b[i], ]), ID = paste("vline", i, sep = ""))
  vline <- c(vline, temp)
}

montserradoBox <- spTransform(montserradoBox, CRS(proj4string(montserrado1)))

allLines <- SpatialLines(c(hline, vline), 
                         proj4string = CRS(as.character(map_projections$proj[map_projections$country == "Liberia"])))

allLines <- spTransform(allLines, CRSobj = CRS(proj4string(montserrado1)))

coords <- SpatialPoints(coords = coords, 
                        proj4string = CRS(as.character(map_projections$proj[map_projections$country == "Liberia"])))

coords <- spTransform(coords, CRSobj = CRS(proj4string(montserrado1)))

coordsSP <- SpatialPoints(coords = coordsSP, 
                          proj4string = CRS(as.character(map_projections$proj[map_projections$country == "Liberia"])))

coordsSP <- spTransform(coordsSP, CRSobj = CRS(proj4string(montserrado1)))
```

# The first stage sample {#stage1}

## Step 1: Find a map

The first step in a S3M survey is to find a map of the survey area. A map showing the locations of all towns and villages in the survey area is essential. Try to find a map showing the locations of all towns and villages in the survey area. You may need to update the map to take into account migration and displacement.

For the coverage survey of 2 counties in Liberia, it will be practical and useful to have:

* A small scale-map (a wide area map but with poor detail) of the entire survey area for each of the 2 counties. If the counties are contiguous (i.e., share borders with each other), the small scale map can be of the two counties together. This map does not need to show the location of all towns and villages in the survey area but it gives a general idea of where the 2 counties are located and main towns and locations and roads. Figure \@ref(fig:smallScaleMap) is a small scale map of Liberia showing counties, roads and main towns and locations. Figure \@ref(fig:smallScaleMapCounty) is a small scale map of two counties showing all the districts within the county, roads and main towns and locations.

\newpage

```{r smallScaleMap, echo = FALSE, eval = TRUE, fig.cap = "Small scale map of Liberia showing counties, roads and points of interest", fig.align = "center", fig.width = 10, fig.height = 10, fig.pos = "H", fig.retina = 1}
# Set margins
par(mar = c(0, 0, 0, 0))
# Plot map
plot(counties, lwd = 2, border = "gray50")
plot(wca, lwd = 4, border = "black", add = TRUE)
plot(primary, lwd = 1, lty = 2, col = "blue", add = TRUE)
plot(paved, lwd = 3, lty = 1, col = "blue", add = TRUE)
plot(poi, pch = 4, cex = 0.3, lwd = 1, col = "darkgreen", add = TRUE)
map.scale()
legend(x = "topright",
       inset = 0.02,
       y.intersp = 1.2,
       bg = "white",
       legend = c("Country borders", "County borders", "Paved roads", 
                  "Primary roads", "Main towns and locations"),
       pch = c(0, 0, NA, NA, 4),
       lty = c(NA, NA, 1, 2, NA),
       lwd = c(3, 2, 2, 1, 2),
       col = c("black", "gray50", "blue", "blue", "darkgreen"),
       cex = 1,
       pt.cex = 2)
```
\newpage

```{r smallScaleMapCounty, echo = FALSE, eval = TRUE, fig.cap = "Small scale map of Montserrado and Grand Bassa in Liberia showing all districts, roads and points of interest", fig.align = "center", fig.width = 6, fig.height = 12, fig.pos = "H", fig.retina = 1}
# Set margins and plot layout
par(mar = c(1, 1, 1, 1), mfrow = c(2, 1))
# Draw first county
plot(subset(districts, admin1Name == "Grand Bassa"), 
     lwd = 1, 
     border = "gray50")
plot(counties, lwd = 1, border = "black", add = TRUE)
plot(wca, lwd = 4, border = "black", add = TRUE)
text(x = counties, 
     labels = counties$admin1name, 
     cex = 2, col = "gray70")
plot(primary, lwd = 1, lty = 2, col = "blue", add = TRUE)
plot(paved, lwd = 3, lty = 1, col = "blue", add = TRUE)
plot(poi, pch = 4, cex = 0.3, lwd = 1, col = "darkgreen", add = TRUE)
map.scale(ratio = FALSE)
# Draw second county
plot(subset(districts, admin1Name == "Montserrado"), 
     lwd = 2, 
     border = "gray50")
plot(counties, lwd = 1, border = "black", add = TRUE)
plot(wca, lwd = 4, border = "black", add = TRUE)
text(x = counties, 
     labels = counties$admin1name, 
     cex = 2, col = "gray70")
plot(primary, lwd = 1, lty = 2, col = "blue", add = TRUE)
plot(paved, lwd = 3, lty = 1, col = "blue", add = TRUE)
plot(poi, pch = 4, cex = 0.3, lwd = 1, col = "darkgreen", add = TRUE)
map.scale(ratio = FALSE)
```
\newpage

* A collection of larger scale maps (a small area map but with good detail) of each of the selected counties and each of the districts within those counties in Liberia. Figure \@ref(fig:largeScaleMapCounty) is a large scale map of Montserrado county showing all districts, roads and all settlements. Figure \@ref(fig:largeScaleMapDistricts) is a collection of large scale maps of each of the districts of Montserrado country showing all roads and all settlements.

&nbsp;

```{r largeScaleMapCounty, echo = FALSE, eval = TRUE, fig.cap = "Large scale map of Montserrado county in Liberia showing all districts, roads and all settlements (towns, villages)", fig.align = "center", fig.width = 10, fig.height = 10, fig.pos = "H", fig.retina = 1}
par(mar = c(0, 0, 0, 0))
plot(subset(liberia::districts, admin1Name == "Montserrado"), lwd = 1, border = "gray50")
plot(liberia::counties, lwd = 4, border = "black", add = TRUE)
plot(wca, lwd = 5, border = "black", add = TRUE)
text(x = subset(counties, admin1name == "Montserrado"), 
     labels = subset(counties, admin1name == "Montserrado")$admin1name, 
     cex = 4, col = "gray70")
raster::text(x = subset(districts, admin1Name == "Montserrado"), 
             labels = subset(districts, admin1Name == "Montserrado")$admin2Name, 
             cex = 1, col = "gray70")
plot(primary, lwd = 2, lty = 2, col = "blue", add = TRUE)
plot(paved, lwd = 2, lty = 1, col = "blue", add = TRUE)
plot(settlements, pch = 4, cex = 0.5, lwd = 1, col = "darkgreen", add = TRUE)
map.scale(ratio = FALSE)
legend(x = "topleft",
       inset = 0.02,
       y.intersp = 1.2,
       bg = "white",
       legend = c("Country borders", "County borders", "Paved roads", 
                  "Primary roads", "All settlements"),
       pch = c(0, 0, NA, NA, 4),
       lty = c(NA, NA, 1, 2, NA),
       lwd = c(3, 2, 2, 1, 2),
       col = c("black", "gray50", "blue", "blue", "darkgreen"),
       cex = 1,
       pt.cex = 2)
```

\newpage

```{r largeScaleMapDistricts, echo = FALSE, eval = TRUE, fig.cap = "Large scale maps of 5 districts of Montserrado county in Liberia showing roads and all settlements (towns, villages)", fig.align = "center", fig.width = 10, fig.height = 15, fig.pos = "H", fig.retina = 1}
# Set margins and plot layout
par(mar = c(1, 1, 1, 1), mfrow = c(3, 2))
# Plot maps
for(i in subset(districts, admin1Name == "Montserrado")$admin2Name) {
  plot(subset(districts, admin1Name == "Montserrado" & admin2Name == i), 
       lwd = 1, 
       border = "black")
  plot(counties, lwd = 2, border = "black", add = TRUE)
  #sp::plot(wca, lwd = 4, border = "black", add = TRUE)
  text(x = subset(districts, admin1Name == "Montserrado" & admin2Name == i), 
       labels = i, 
       cex = 3, 
       col = "gray70")
  plot(primary, lwd = 1, lty = 2, col = "blue", add = TRUE)
  plot(paved, lwd = 3, lty = 1, col = "blue", add = TRUE)
  plot(settlements, pch = 4, cex = 0.3, lwd = 1, col = "darkgreen", add = TRUE)
  map.scale(ratio = FALSE)
}
```

\newpage

The small-scale maps in Figures \@ref(fig:smallScaleMap) and \@ref(fig:smallScaleMapCounty) will be useful for identifying initial sampling locations. 

The large-scale maps in Figures \@ref(fig:largeScaleMapCounty) and \@ref(fig:largeScaleMapDistricts) will be useful for identifying the precise location of sampling points and for selecting the communities to be sampled.

\newpage

## Step 2: Decide the area to represent each sampling point

The easiest way of thinking about this is as a function of the intended maximum distance ($d$) of any community from the nearest sampling point (see Figure \@ref(fig:distance1).

&nbsp;

```{r distance1, echo = FALSE, eval = TRUE, fig.cap = "Conceptual presentation of the area represented by each sampling point", fig.align = "center", fig.pos = "H", fig.retina = 1}
knitr::include_graphics("figures/step2.png")
```

&nbsp;

There are other ways of thinking about $d$. These are:

1. **The area of each triangular tile**: This can be calculated using the formula:

$$ A ~ = ~ \tan30^ \circ ~ \times ~ \frac{9}{4} ~ d ^ 2 $$

For $d ~ = ~ 10 ~ \text{km}$ the area of each triangular tile will be about:

$$ A ~ = ~ \tan30^ \circ ~ \times ~ \frac{9}{4} ~ d ^ 2 ~ \approx ~ 1.3 ~ \times ~ 100 ~ = ~ 130 ~ \text{km} ^ 2 $$

2. **Practicability**: Most of the time spent in the field when doing a survey will be in travelling to and from sampling points. Having many sampling points can make for an expensive and / or lengthy survey. If you know how many sampling points that you can afford to take ($m$) then you can make a **very approximate** estimate of a suitable value for d using the following *rule-of-thumb* formula:

$$ d ~ \approx ~ \sqrt{\frac{\text{Program Area}}{m}} $$

The value of $d$ calculated using this formula is approximate and should be used as a starting point for a number of trial samples using the procedure outlined below.

&nbsp;

+----------+---------------+----------+---------------+
| **Pair** | **Distance**  | **Pair** | **Distance**  |
+:========:+:=============:+:========:+:=============:+
| 1        | 21 km         | 13       | 13 km         |
+----------+---------------+----------+---------------+
| 2        | 14 km         | 14       | 11 km         |
+----------+---------------+----------+---------------+
| 3        | 13 km         | 15       | 12 km         |
+----------+---------------+----------+---------------+
| 4        | 17 km         | 16       | 15 km         |
+----------+---------------+----------+---------------+
| 5        | 11 km         | 17       | 13 km         |
+----------+---------------+----------+---------------+
| 6        | 14 km         | 18       | 16 km         |
+----------+---------------+----------+---------------+
| 7        | 12 km         | 19       | 18 km         |
+----------+---------------+----------+---------------+
| 8        | 15 km         | 20       | 13 km         |
+----------+---------------+----------+---------------+
| 9        | 16 km         | 21       | 8 km          |
+----------+---------------+----------+---------------+
| 10       | 12 km         | 22       | 16 km         |
+----------+---------------+----------+---------------+
| 11       | 17 km         | 23       | 18 km         |
+----------+---------------+----------+---------------+
| 12       | 14 km         | 24       | 14 km         |
+----------+---------------+----------+---------------+

&nbsp;

```{r distance2, echo = FALSE, eval = TRUE, fig.cap = "Distances of communities to the nearest substantial markets", fig.align = "center", fig.pos = "H", fig.retina = 1}
include_graphics("figures/step2a.png")
```

&nbsp;

```{block2, type = "rmdcalc"}
Following are steps to estimate value of $d$ based on distances that carers are willing or able to walk to access services.

&nbsp;

Using the information from the distance table, add the distances together: 
  
$$ \sum \text{Distance} ~ = ~ 343 ~ \text{km} $$

&nbsp;
  
Divide the result by the number of paired distances:
  
$$ \frac{\sum \text{Distance}}{\text{Number of paired distances}} ~ = ~ \frac{343}{24} ~ = ~ 14.29 ~ \text{km} $$

&nbsp;
  
Divide the result by two:
  
$$ d ~ = ~ \frac{14.29}{2} ~ = ~ 7.15 ~ \approx ~ 7 ~ \text{km} $$
```
  
&nbsp;
  
This is an estimate of the distance that carers are willing or able to walk to access services. Only distances between towns and villages with markets are used in this calculation.

A way of deciding a value for $d$ that is based on the economic geography of the survey area is to set $d$ to one half of the mean distance between neighbouring pairs of communities with substantial markets.

S3M surveys have been done using a wide range (i.e. from $d ~ = ~ 8 ~ \text{km}$ to $d ~ = ~ 33 ~ \text{km}$) of values for $d$. A value for $d$ of 10 km or 12 km will probably be small enough in most circumstances.

\newpage

## Step 3: Draw a grid over the map

```{r grid1, echo = FALSE, eval = TRUE, fig.cap = "Montserrado county with a rectangular grid defined by d of 6 km", fig.align = "center", fig.width = 8, fig.height = 8, fig.pos = "H", fig.retina = 1}
par(mar = c(0, 0, 0, 0))
plot(montserradoBox, lty = 0)
plot(counties, add = TRUE)
plot(montserrado1, lwd = 3, add = TRUE)
plot(primary, lwd = 2, lty = 2, col = "blue", add = TRUE)
plot(paved, lwd = 2, lty = 1, col = "blue", add = TRUE)
plot(settlements, pch = 4, cex = 0.5, lwd = 1, col = "darkgreen", add = TRUE)
plot(allLines, add = TRUE)
legend(x = "topleft",
       inset = 0.02,
       y.intersp = 1.2,
       bg = "white",
       legend = c("County borders", "Montserrado borders", "Paved roads", 
                  "Primary roads", "All settlements"),
       pch = c(0, 0, NA, NA, 4),
       lty = c(NA, NA, 1, 2, NA),
       lwd = c(1, 3, 2, 2, 2),
       col = c("black", "black", "blue", "blue", "darkgreen"),
       cex = 1,
       pt.cex = 2)
map.scale()
```

&nbsp;

The next step is to draw a grid over the map.

The size of the grid is determined by the distance ($d$) that you decided in **Step 2**.

The grid is rectangular rather than square. This allows us to place sampling points at the centres of hexagons in a hexagonal grid without the need to draw a hexagonal grid (see **Step 4**).

The width of the grid in the east-west ($x$) direction is different from the height of the grid in the north-south ($y$) direction.

The width of the grid in the east-west ($x$) direction is calculated using:

$$ x ~ = ~ \frac{3d}{2} $$

where $d$ is the distance ($d$) that you decided in **Step 2**.

The height of the grid in the north-south ($y$) direction can be calculated using:

$$ y ~ = ~ \frac{\sqrt{3}d}{2} $$

where $d$ is the distance ($d$) that you decided in **Step 2**.

For example, in Figure \@ref(fig:grid1), we used $d ~ = ~ 6 ~ \text{km}$. This value of $d$ creates a rectangular grid with the following dimensions:

$$ x ~ = ~ \frac{3d}{2} ~ = ~ \frac{3 ~ \times ~ 6}{2} ~ = ~ \frac{18}{2} ~ = ~ 9 ~ \text{km} $$

and:

$$ y ~ = ~ \frac{\sqrt{3}d}{2} ~ \approx ~ \frac{1.73 ~ \times ~ 6}{2} ~ \approx ~ \frac{10.38}{2} ~ \approx ~ 5.2 ~ \text{km} $$

So, the grid in Figure \@ref(fig:grid1) is 9 km long on the east-west direction and 5.2 km on the north and south direction.

\newpage

The table below shows the grid sizes for different values of $d$:

+--------+------------+------------+-----+--------+------------+------------+
| **d**  | **x**      | **y**      |     | **d**  | **x**      | **y**      |
+=======:+===========:+===========:+=====+=======:+===========:+===========:+
| 5      | 7.5        | 4.3        |     | 13     | 19.5       | 11.3       |
+--------+------------+------------+-----+--------+------------+------------+
| 6      | 9.0        | 5.2        |     | 14     | 21.0       | 12.1       |
+--------+------------+------------+-----+--------+------------+------------+
| 7      | 10.5       | 6.1        |     | 15     | 22.5       | 13.0       |
+--------+------------+------------+-----+--------+------------+------------+
| 8      | 12.0       | 6.9        |     | 16     | 24.0       | 13.9       |
+--------+------------+------------+-----+--------+------------+------------+
| 9      | 13,5       | 7.8        |     | 17     | 25.5       | 14.7       |
+--------+------------+------------+-----+--------+------------+------------+
| 10     | 15.0       | 8.7        |     | 18     | 27.0       | 15.6       |
+--------+------------+------------+-----+--------+------------+------------+
| 11     | 16.5       | 19.5       |     | 19     | 28.5       | 16.5       |
+--------+------------+------------+-----+--------+------------+------------+
| 12     | 18.0       | 10.4       |     | 20     | 30.0       | 17.3       |
+--------+------------+------------+-----+--------+------------+------------+

When drawing the grid make sure that it covers the entire survey area.

It is usually best to draw a grid that covers an area that is a little larger than the entire survey area. This helps to ensure that the survey will sample from the entire survey area.

The grid can be drawn using marker pens onto plastic film overlaying the map. This protects the map and allows you to reposition the grid to improve the coverage of the sample should this be needed.

If you are drawing the grid directly onto the map then use a soft pencil (e.g. a *2B* or *#1* pencil). A soft pencil will not damage the surface of the map and is easy to erase using a soft rubber eraser should you make a mistake or need to draw a different grid.

\newpage

## Step 4: Create an even spread of sampling points

```{r grid2, echo = FALSE, eval = TRUE, fig.cap = "Montserrado county with a rectangular grid defined by d of 6 km and alternating intersections of the grid used to identify sampling points", fig.align = "center", fig.width = 8, fig.height = 8, fig.pos = "H", fig.retina = 1}
par(mar = c(0, 0, 0, 0))
plot(montserradoBox, lty = 0)
plot(counties, add = TRUE)
plot(montserrado1, lwd = 3, add = TRUE)
plot(primary, lwd = 2, lty = 2, col = "blue", add = TRUE)
plot(paved, lwd = 2, lty = 1, col = "blue", add = TRUE)
plot(settlements, pch = 4, cex = 0.5, lwd = 1, col = "darkgreen", add = TRUE)
plot(allLines, add = TRUE)
plot(coordsSP, pch = 1, cex = 2, col = "red", add = TRUE)
legend(x = "topleft",
       inset = 0.02,
       y.intersp = 1.2,
       bg = "white",
       legend = c("County borders", "Montserrado borders", "Paved roads", 
                  "Primary roads", "All settlements", "Sampling points"),
       pch = c(0, 0, NA, NA, 4, 1),
       lty = c(NA, NA, 1, 2, NA, NA),
       lwd = c(1, 3, 2, 2, 2, 2),
       col = c("black", "black", "blue", "blue", "darkgreen", "red"),
       cex = 1,
       pt.cex = 2)
map.scale()
```

Sampling points are located at the intersections of the rectangular grid in a staggered fashion. Alternate intersections of the grid in the x (east-west) and y (north-south) directions are used:

\newpage

```{r grid2a, echo = FALSE, eval = TRUE, fig.cap = "Selecting alternating intersections of the grid in the x and y directions to spread sampling points evenly", fig.align = "center", fig.pos = "H", fig.retina = 1}
include_graphics("figures/grid2a.png")
```

Note how this process places sampling points at the centres of hexagons in a hexagonal grid without the need to draw a hexagonal grid.

Make sure that your sample points go right to the edge (or even over the edge) of the survey area. This helps to ensure that the survey will sample from the entire survey area.

\newpage

## Step 5: Select the communities to sample

```{r grid3, echo = FALSE, eval = TRUE, fig.cap = "Montserrado county with a rectangular grid defined by d of 6 km and sampling points moved to the nearest communities", fig.align = "center", fig.width = 8, fig.height = 8, fig.pos = "H", fig.retina = 1}

xx <- get_nearest_point(data = settlements, 
                        data.x = "COORD_X", 
                        data.y = "COORD_Y", 
                        query = coordsSP)

villagesSP <- SpatialPoints(coords = xx[ , c("COORD_X", "COORD_Y")],
                            proj4string = CRS(proj4string(montserrado1)))[montserrado1]


par(mar = c(0, 0, 0, 0))
plot(montserradoBox, lty = 0)
plot(counties, add = TRUE)
plot(montserrado1, lwd = 3, add = TRUE)
plot(primary, lwd = 2, lty = 2, col = "blue", add = TRUE)
plot(paved, lwd = 2, lty = 1, col = "blue", add = TRUE)
plot(settlements, pch = 4, cex = 0.5, lwd = 1, col = "darkgreen", add = TRUE)
plot(allLines, add = TRUE)
#plot(coordsSP, pch = 1, cex = 2, col = "red", add = TRUE)
plot(villagesSP, pch = 1, cex = 2, col = "red", add = TRUE)
legend(x = "topleft",
       inset = 0.02,
       y.intersp = 1.2,
       bg = "white",
       legend = c("County borders", "Montserrado borders", "Paved roads", 
                  "Primary roads", "All settlements", "Sampling points"),
       pch = c(0, 0, NA, NA, 4, 1),
       lty = c(NA, NA, 1, 2, NA, NA),
       lwd = c(1, 3, 2, 2, 2, 2),
       col = c("black", "black", "blue", "blue", "darkgreen", "red"),
       cex = 1,
       pt.cex = 2)
map.scale()
```

Select the community (or communities) closest to the sampling points identified in **Step 4**.

The position of the sampling point is moved to the position of the selected community. This is shown in the
diagram above.

You may drop sampling points if you find that many sampling points are clustered closely together.

You may move or add sampling points if you find that there are populated areas that do not contain sampling points.

The aim is to create a roughly even spread of sampling points over the entire survey area.

```{block2, type = "rmdcaution"}
The S3M sample is defined using a systematic sampling method. Like any systematic sampling method, an S3M sample can produce biased estimates if there is periodic variation in prevalence and / or coverage and the sampling points tend to coincide with this periodicity. This is difficult to control for without prior knowledge of the periodic variation, although simple checks such as ensuring that sampling points are not all in valleys or all on hilltops, and adjusting the grid position accordingly, should help to minimise this problem.
```

A good way to check if you have an even spread of sampling points over the entire survey area is to do a trial *triangulation* of the selected sampling points. This involves dividing up the survey area into non-overlapping triangles with a sampling point at each vertex.

There will usually be many ways to divide the survey area into triangles. The best triangulation is one that results in small equilateral triangles (i.e. triangles with all sides of equal length) or small and nearly equilateral triangles. Avoid long and narrow triangles. Avoid large triangles.

You can triangulate “by eye” or automatically (i.e. using a computer). If you use a computer to do this then you should use software that produces a *Delaunay triangulation*.

You may drop sampling points if you find that many sampling points are clustered closely together.

You may move or add sampling points if you find that there are populated areas that do not contain sampling points.

The aim is to create a roughly even spread of sampling points over the entire survey area. 

The diagrams above show a trial triangulation with only a few long and narrow triangles :

* One sampling point (labelled x1) has been added to ensure that the sample covers almost the entire survey area.

* Four sampling points (labelled m1, m2, m3, and m4) have been moved to ensure that there are few long and narrow triangles.

**The sample will, to some extent, be dictated by the distribution of communities in the survey area. It is usual to find that you have some large triangles and some long and narrow triangles in your final triangulation. You should try to keep the number of these “problem” triangles to a minimum.**

The process of selecting communities to sample is:

1. Start by defining the sample using the grid based approach outlined above.

2. Use a trial triangulation. This can be done “by eye” or using a computer. Check for an even spatial sample:

* Most triangles should be short and wide.

* Very few triangles should be long and narrow.

* The triangles should be of roughly equal size.

* The complete set of triangles should cover all (or almost all) of the survey area.

3. Move or add sampling points to improve the sample (i.e. to avoid long and narrow triangles, to avoid large triangles, to make triangles roughly equal in size, and to ensure the sample covers all or almost all of the survey area). Triangulate again. Repeat this process until you are happy with the sample.

**The sample will, to some extent, be dictated by the distribution of communities in the survey area. It is usual to find that you have some large triangles and some long and narrow triangles in your final triangulation. You should try to keep the number of these “problem” triangles to a minimum.**

\newpage

## Step 6: Label each sampling point

Give each sampling point a unique identifying label:

* The label may be a number or a name.

* The label must be unique.

* The label is used to identify which community belongs to which sampling point.

These labels are used when collecting, organising, and analysing data.

\newpage

## Step 7: Label each triangular tile

Give each triangular tile a unique identifying label:

* The label may be a number or a name.

* The label must be unique.

* The label is used to identify which communities belong to which triangular tile.

These labels are used when collecting, organising, and analysing data.

```{block2, type = "rmdnote"}
This step is only required if you will be using the simple analysis provided by the RAnalyticFlow workflow. More complicated analysis methods will usually not use the tile labels created in this step.
```

\newpage

## Step 8: Describe the sample in numbers

To analyse and map data you will need to create two files:

* **The PSU file:** This is a file that describes each sampling point (a sampling point is sometimes called a primary sampling unit or PSU). This file **must** have the following named columns and the names **must** be **exactly** as given here:

+--------------------+----------------------------------------+----------------------------------------+
| **Column Name**    | **Contains**                           | **Notes**                              |
+====================+========================================+========================================+
| **psu**            | Unique identifying label for a sampling| Must be unique.                        |
|                    | point (from **Step 6**).               |                                        |
+--------------------+----------------------------------------+----------------------------------------+
| **pop**            | Population of the community at the     | Can be taken from census or program    |
|                    | sampling point.                        | data or collected when the sampling    |
|                    |                                        | point is visited.                      |
+--------------------+----------------------------------------+----------------------------------------+
| **latDegrees**     | Latitude of the sampling point         | Optional                               |
+--------------------+----------------------------------------+----------------------------------------+
| **latMinutes**     | Minutes of latitude should be recorded | Optional                               |
|                    | in decimal minutes                     |                                        |
+--------------------+----------------------------------------+----------------------------------------+
| **lonDegrees**     | Longitude of the sampling point        | Optional                               |
+--------------------+----------------------------------------+----------------------------------------+
| **lonMinutes**     | Minutes of longitude should be recorded| Optional                               |
|                    | in decimal minutes                     |                                        |
+--------------------+----------------------------------------+----------------------------------------+

The PSU file may also contain other columns such as district name, village name, and date visited. These columns may help when describing the sample in survey reports. If (e.g.) the survey area covers many districts then a column giving the district name will be useful if district-level summaries are required.

* **The TILE file:** This is a file that links sampling points to tiles. This file has only four columns which must have the exact names:

+--------------------+----------------------------------------------------------+
| **Column Name**    | **Contains**                                             |
+====================+==========================================================+
| **tile**           | Unique identifying label a tile (from **Step 7**)        |
+--------------------+----------------------------------------------------------+
| **psu1**           | Identifying label for vertex 1 of the tile.              |
+--------------------+----------------------------------------------------------+
| **psu2**           |  Identifying label for vertex 2 of the tile.             |
+--------------------+----------------------------------------------------------+
| **psu3**           |  Identifying label for vertex 3 of the tile.             |
+--------------------+----------------------------------------------------------+

For example, the first four rows of the TILE file for the sample shown in the illustration to **Step 7** would be:

+----------+----------+----------+----------+
| **tile** | **psu1** | **psu2** | **psu3** |
+:========:+:========:+:========:+:========:+
| 1        | 4        | 5        | 8        |
+----------+----------+----------+----------+
| 2        | 5        | 8        | 10       |
+----------+----------+----------+----------+
| 3        | 5        | 9        | 10       |
+----------+----------+----------+----------+

The TILE file is only required if you will be using the simple analysis provided by the **RAnalyticFlow** workflow. More complicated analysis methods may not need a TILE file.

Both of these files can be created using a spreadsheet package such as Microsoft Excel or OpenOffice Calc but they should be exported as comma-separated-value (CSV) files before use by the **RAnalyticFlow** workflow. Do **not** use commas (i.e. “,”) in any cell when entering data.

\newpage

## Step 9: Plan data collection

Now you have identified the location and number of sampling points you can draw up a project plan (using your favourite or institutional project management tools) and budget. When drawing up the timetable and budget it is common to assume that one team will sample one sampling point in one day.

<!--chapter:end:03-firststage.Rmd-->

# The second stage sample {#stage2}

## Step 10: Within-community sampling

The sampling process that you use to select a sample from a community will depend on what the survey is investigating.

If you are investigating multiple indicators which apply to different groups of individuals then you may find it easier to use different sampling methods for different indicators. You can think of this as having different surveys for different indicators sampled from the same set of communities at the same time.

If you are evaluating a program treating SAM you can efficiently find SAM cases using an active and adaptive (snowball) case-finding method. If you are also evaluating TSFP and FBPM programs using house- to-house and door-to-door screening then you will not need to use active and adaptive case-finding as the screening process will also identify SAM cases. SAM is a rare condition. This means that estimates and maps of SAM prevalence and SAM treatment coverage may be based on only a small number of cases from a small number of sampling points. This problem can be avoided by using a “top-up” sample collected using an active and adaptive case-finding method in a small set of communities neighbouring the selected sampling point.

If you are evaluating (e.g.) TSFP and FBPM programs then the active and adaptive case-finding may only find the most severe cases. In this case, house-to-house and door-to-door screening will be the most appropriate way to find eligible persons (cases). If a sampling point is located in a village then the entire population can be screened. If a sampling point is located in a large village or town then the village or town can be divided into a set of segments and the entire population of only a sample of these segments are then screened (see **Appendix A**).

If you are evaluating a BCC program then you can apply your BCC questions to the carers of children and to the PLWs that you find in the sample.

\newpage

## Step 11: Collect and record the data

Datasets for need and coverage surveys of selective-entry feeding programs are usually simple and can be collected using simple tabular forms.

Here is an example of a form used to collect coverage data on TSFP and FPBM programs for children:

Here is an example of a form used to collect coverage data on TSFP and FPBM programs for PLWs:

The “BCC confirmed by message recall” column records whether the respondent can recall any messages that match with the program's BCC key messages.

The data collected using the tabular forms will allow you to estimate or classify need and coverage. They do not, however, allow you to know the reasons for coverage failure. To collect this data we apply a “barriers” questionnaire to uncovered cases (PLWs) or the carers of uncovered cases (children). Here is an example of a barriers questionnaire:

The barriers questionnaire is applied only to non-covered cases.

Remember to refer all non-covered cases to the appropriate program.

\newpage

## Step 12: Enter the collected data

Coverage survey data is simple enough to be entered (and analysed) using spreadsheet packages such as Microsoft Excel or OpenOffice Calc.

If you want to analyse your data using a spreadsheet then you can use column names that make sense to you. If you want to analyse your data using the **RAnalyticFlow** workflow (see **Step 13**) then the column names
**must** be **exactly**:

**Children**

+---------------+------------------------------+
| **Column**    | **Contains**                 |
+===============+==============================+
| **age**       | Age of child in months       |
+---------------+------------------------------+
| **sex**       | Sex of child                 |
|               | 1 = Male; 2 = Female         |
+---------------+------------------------------+
| **muac**      | MUAC in **mm**               |
+---------------+------------------------------+
| **screened**  | MUAC taken previously        |
|               | (in previoius 4 weeks)       |
+---------------+------------------------------+
| **oedema**    | Oedema                       |
+---------------+------------------------------+
| **program**   | Program child is attending   |
+---------------+------------------------------+
| **confirmBCC**| BCC contact                  |
|               | (confirmed by message recall)|
+---------------+------------------------------+

<!--chapter:end:04-secondstage.Rmd-->

# Analysis {#analysis}



<!--chapter:end:05-analysis.Rmd-->

`r if (knitr::is_html_output()) '
# References {-}
'`

<!--chapter:end:06-references.Rmd-->

